/* ============================================================
   Wi-Fi Heatmap — core (ใช้ซ้ำได้ 2 อินสแตนซ์: Planning / Survey)
   โคลน UI/Behavior 1:1 ด้วยการเปลี่ยน prefix เท่านั้น
   ============================================================ */

const MATERIALS={
  drywall:{name:'ผนังยิปซัม (Drywall)',color:'#98c1ff',att:{'2.4':3,'5':4}},
  glass:{name:'กระจก',color:'#7de1ff',att:{'2.4':4,'5':6}},
  wood:{name:'ไม้',color:'#9ae27b',att:{'2.4':5,'5':7}},
  brick:{name:'อิฐ/คอนกรีตมวลเบา',color:'#ffb673',att:{'2.4':8,'5':10}},
  concrete:{name:'คอนกรีตเสริมเหล็ก',color:'#ff8f8f',att:{'2.4':12,'5':15}},
  metal:{name:'โลหะแผ่น/ประตูเหล็ก',color:'#ffd36a',att:{'2.4':20,'5':24}},
  human:{name:'ร่างกายคน (เฉลี่ย)',color:'#d6b3ff',att:{'2.4':3,'5':4}},
};

const RSSI_MIN=-80, RSSI_MAX=-50;
const P_GRAY=-67, P_YELLOW=-60, P_GREEN=-30;
const GRAY_BASE=[128,128,128], GRAY_LIGHT=[220,220,220];
const N_BY_BAND={'2.4':2.2,'5':2.5};
const CONTOUR_LEVELS=[-20,-25,-30,-35,-40,-45,-50,-55,-60,-65,-70,-75,-80];

const $=s=>document.querySelector(s);
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;
const mix=(c1,c2,t)=>[Math.round(lerp(c1[0],c2[0],t)),Math.round(lerp(c1[1],c2[1],t)),Math.round(lerp(c1[2],c2[2],t))];
const rgbStr=([r,g,b])=>`rgb(${r},${g},${b})`;

class WiFiApp{
  constructor(prefix){
    this.p=prefix; // เช่น 'Planning' หรือ 'Survey'

    // canvases
    this.canvas = $(`#canvas${this.p}`);
    this.ctx    = this.canvas.getContext('2d',{willReadFrequently:true});
    this.overlay= $(`#overlay${this.p}`);
    this.octx   = this.overlay.getContext('2d',{willReadFrequently:true});
    this.stage  = $(`#stage${this.p}`);

    // UI refs
    this.UI = {
      modeBadge: $(`#modeBadge${this.p}`),
      scaleLabel: $(`#scaleLabel${this.p}`),
      alpha: $(`#alpha${this.p}`),
      blurPx: $(`#blurPx${this.p}`),
      legendMin: $(`#legendMin${this.p}`),
      legendMax: $(`#legendMax${this.p}`),
      grad: $(`#grad${this.p}`),
      probe: $(`#probe${this.p}`),
      probeVal: $(`#probeVal${this.p}`),
      probeMeta: $(`#probeMeta${this.p}`),
      probeSw: $(`#sw${this.p}`),
      apList: $(`#apList${this.p}`),
      matList:$(`#matList${this.p}`),
      apLabel:$(`#apLabel${this.p}`),
      apP0:   $(`#apP0${this.p}`),
      apBand: $(`#apBand${this.p}`),
      matType:$(`#matType${this.p}`),
      matAtt: $(`#matAtt${this.p}`),
      fileInput:$(`#fileInput${this.p}`),
      btnClear:$(`#btnClear${this.p}`),
      btnZoomIn:$(`#btnZoomIn${this.p}`),
      btnZoomOut:$(`#btnZoomOut${this.p}`),
      btnZoomReset:$(`#btnZoomReset${this.p}`),
      btnScale:$(`#btnScale${this.p}`),
      btnIdle:$(`#btnIdle${this.p}`),
      btnAP:$(`#btnAP${this.p}`),
      btnAPUndo:$(`#btnAPUndo${this.p}`),
      btnAPClear:$(`#btnAPClear${this.p}`),
      btnMat:$(`#btnMat${this.p}`),
      btnMatUndo:$(`#btnMatUndo${this.p}`),
      btnMatClear:$(`#btnMatClear${this.p}`),
      btnRender:$(`#btnRender${this.p}`),
      btnExport:$(`#btnExport${this.p}`),
      btnSave:$(`#btnSave${this.p}`),
      loadJson:$(`#loadJson${this.p}`),
      apPreset:$(`#apPreset${this.p}`),
      btnUsePreset:$(`#btnUsePreset${this.p}`),
    };

    // state
    this.worldW=this.canvas.width; this.worldH=this.canvas.height;
    this.view={ scale:1, tx:0, ty:0, min:0.2, max:6 };
    this.floorImg=null;
    this.aps=[];        // {x,y,label,p0,band,preset?}
    this.segments=[];   // {a:{x,y}, b:{x,y}, type, att24, att5}
    this.mode='idle';
    this.dragging=false; this.dragStart=null;
    this.spacePan=false; this.panAnchor=null;
    this.scalePxPerMeter=null;
    this.hasRendered=false;
    this.heatCanvas=null; this.heatField=null;
    this.buildingHeat=false;
    this.AP_PRESETS={}; window.__currentApPreset=null;

    this._wireUI();
    this._initMatDrop();
    this._resetView();
    this._makeFixedLegend();
    this._drawAll();
    this._loadApPresets();
  }

  /* ===== helpers ===== */
  _setView(s,tx,ty){ this.view.scale=clamp(s,this.view.min,this.view.max); this.view.tx=tx; this.view.ty=ty; this._drawAll(); }
  _resetView(){
    const pad=20, sx=(this.canvas.width-2*pad)/this.worldW, sy=(this.canvas.height-2*pad)/this.worldH, s=Math.min(sx,sy);
    this._setView(s,pad,pad);
  }
  _worldToScreen(p){ return { x:p.x*this.view.scale+this.view.tx, y:p.y*this.view.scale+this.view.ty }; }
  _screenToWorld(p){ return { x:(p.x-this.view.tx)/this.view.scale, y:(p.y-this.view.ty)/this.view.scale }; }
  _getCanvasPos(e){ const r=this.canvas.getBoundingClientRect(); const sx=e.clientX-r.left, sy=e.clientY-r.top;
    return { screen:{x:sx,y:sy}, world:this._screenToWorld({x:sx,y:sy}), rect:r }; }

  _colorFromRSSI(v){
    if(v<=P_GRAY){ const t=clamp((P_GRAY-v)/(P_GRAY-RSSI_MIN),0,1); return mix(GRAY_BASE,GRAY_LIGHT,t); }
    if(v<=P_YELLOW){ const t=(v-P_GRAY)/(P_YELLOW-P_GRAY); return mix(GRAY_BASE,[255,255,0],t); }
    if(v<=P_GREEN){ const t=(v-P_YELLOW)/(P_GREEN-P_YELLOW); return mix([255,255,0],[0,255,0],t); }
    return [0,255,0];
  }

  _drawBase(){
    const ctx=this.ctx;
    ctx.save(); ctx.setTransform(1,0,0,1,0,0); ctx.clearRect(0,0,this.canvas.width,this.canvas.height); ctx.restore();
    ctx.save(); ctx.setTransform(this.view.scale,0,0,this.view.scale,this.view.tx,this.view.ty);
    if(!this.floorImg){
      ctx.fillStyle='#0c1022'; ctx.fillRect(0,0,this.worldW,this.worldH);
      ctx.strokeStyle='#1c264a'; ctx.lineWidth=1/this.view.scale;
      for(let x=0;x<this.worldW;x+=40){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,this.worldH);ctx.stroke()}
      for(let y=0;y<this.worldH;y+=40){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(this.worldW,y);ctx.stroke()}
    }else ctx.drawImage(this.floorImg,0,0,this.worldW,this.worldH);
    ctx.restore();
    this._hideProbe();
  }
  _drawPermanent(){
    const ctx=this.ctx;
    ctx.save(); ctx.setTransform(this.view.scale,0,0,this.view.scale,this.view.tx,this.view.ty);
    // materials
    this.segments.forEach(s=>{
      const m=MATERIALS[s.type]||{color:'#fff',name:s.type};
      ctx.lineWidth=3/this.view.scale; ctx.strokeStyle=m.color;
      ctx.beginPath(); ctx.moveTo(s.a.x,s.a.y); ctx.lineTo(s.b.x,s.b.y); ctx.stroke();

      const mx=(s.a.x+s.b.x)/2, my=(s.a.y+s.b.y)/2, sp=this._worldToScreen({x:mx,y:my});
      ctx.save(); ctx.scale(1/this.view.scale,1/this.view.scale);
      ctx.fillStyle='#e8ecf1'; ctx.font='11px ui-monospace,monospace';
      const label=`${m.name} · 2.4:${s.att24} dB · 5:${s.att5} dB`;
      ctx.fillText(label, sp.x+6, sp.y-6);
      ctx.restore();
    });
    // APs
    this.aps.forEach(a=>{
      ctx.fillStyle='#8fd3ff';
      ctx.beginPath(); ctx.arc(a.x,a.y,7/this.view.scale,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle='#2a7fff'; ctx.lineWidth=2/this.view.scale; ctx.stroke();

      const sp=this._worldToScreen(a);
      ctx.save(); ctx.scale(1/this.view.scale,1/this.view.scale);
      ctx.fillStyle='#cfe6ff'; ctx.font='12px ui-monospace,monospace';
      ctx.fillText(`${a.label||'AP'} · P0:${a.p0}dBm ${a.band||'5'}GHz`, sp.x+10, sp.y-8);
      ctx.restore();
    });
    ctx.restore();
  }
  _drawContours(levels, step=2){
    const ctx=this.ctx;
    if(!this.heatField) return;
    ctx.save(); ctx.setTransform(this.view.scale,0,0,this.view.scale,this.view.tx,this.view.ty);
    ctx.strokeStyle='#fff'; ctx.lineWidth=1.3/this.view.scale;
    const w=this.worldW, h=this.worldH, nx=Math.floor((w-1)/step), ny=Math.floor((h-1)/step);
    for(const L of levels){
      for(let gy=0;gy<ny;gy++){
        const y0=gy*step,y1=y0+step;
        for(let gx=0;gx<nx;gx++){
          const x0=gx*step,x1=x0+step;
          const i00=y0*w+x0,i10=y0*w+x1,i11=y1*w+x1,i01=y1*w+x0;
          const v00=this.heatField[i00],v10=this.heatField[i10],v11=this.heatField[i11],v01=this.heatField[i01];
          const b0=v00>=L?1:0,b1=v10>=L?1:0,b2=v11>=L?1:0,b3=v01>=L?1:0;
          const code=(b0)|(b1<<1)|(b2<<2)|(b3<<3); if(code===0||code===15) continue;
          const interp=(xa,ya,xb,yb,va,vb)=>{const t=(L-va)/((vb-va)||1e-9);return [xa+(xb-xa)*t,ya+(yb-ya)*t];};
          const T=interp(x0,y0,x1,y0,v00,v10), R=interp(x1,y0,x1,y1,v10,v11),
                B=interp(x0,y1,x1,y1,v01,v11), Lp=interp(x0,y0,x0,y1,v00,v01);
          const seg=(p,q)=>{ctx.beginPath();ctx.moveTo(p[0],p[1]);ctx.lineTo(q[0],q[1]);ctx.stroke();};
          switch(code){
            case 1: case 14: seg(Lp,T); break;
            case 2: case 13: seg(T,R); break;
            case 3: case 12: seg(Lp,R); break;
            case 4: case 11: seg(R,B); break;
            case 5: seg(Lp,T); seg(R,B); break;
            case 6: case 9: seg(T,B); break;
            case 7: case 8: seg(Lp,B); break;
            case 10: seg(T,R); seg(Lp,B); break;
          }
        }
      }
    }
    ctx.restore();
  }
  _drawAll(){
    this.UI.legendMin.textContent=RSSI_MIN;
    this.UI.legendMax.textContent=RSSI_MAX;
    this._drawBase();
    if(this.heatCanvas){
      const alpha=clamp(parseFloat(this.UI.alpha?.value||'0.6'),0,1);
      const blurPx=Math.max(0,parseInt(this.UI.blurPx?.value||'16',10));
      const ctx=this.ctx;
      ctx.save(); ctx.setTransform(this.view.scale,0,0,this.view.scale,this.view.tx,this.view.ty);
      ctx.globalAlpha=alpha; if(blurPx>0) ctx.filter=`blur(${blurPx}px)`;
      ctx.drawImage(this.heatCanvas,0,0,this.worldW,this.worldH);
      ctx.filter='none'; ctx.globalAlpha=1; ctx.restore();
    }
    this._drawPermanent();
    if(this.heatField) this._drawContours(CONTOUR_LEVELS,2);
  }

  _makeFixedLegend(){
    const g=this.UI.grad; if(!g) return;
    const cvs=document.createElement('canvas'); cvs.width=256; cvs.height=1;
    const c=cvs.getContext('2d');
    const span1=P_GRAY-RSSI_MIN, span2=P_YELLOW-P_GRAY, span3=P_GREEN-P_YELLOW, usable=240;
    const s=usable/(span1+span2+span3);
    const px1=Math.round(span1*s), px2=Math.round(span2*s), px3=Math.round(span3*s), pxG=256-(px1+px2+px3);
    let x=0;
    for(let i=0;i<px1;i++,x++){ const t=i/(px1||1), col=mix(GRAY_LIGHT,GRAY_BASE,t); c.fillStyle=rgbStr(col); c.fillRect(x,0,1,1); }
    for(let i=0;i<px2;i++,x++){ const t=i/(px2||1), col=mix(GRAY_BASE,[255,255,0],t); c.fillStyle=rgbStr(col); c.fillRect(x,0,1,1); }
    for(let i=0;i<px3;i++,x++){ const t=i/(px3||1), col=mix([255,255,0],[0,255,0],t); c.fillStyle=rgbStr(col); c.fillRect(x,0,1,1); }
    c.fillStyle='rgb(0,255,0)'; c.fillRect(x,0,pxG,1);
    g.style.backgroundImage=`url(${cvs.toDataURL()})`;
  }

  _pathObstacleLoss(pFrom,pTo,band){
    const segs=this.segments; let loss=0;
    const orient=(a,b,c)=> (b.x-a.x)*(c.y-a.y) - (b.y-a.y)*(c.x-a.x);
    const onSeg=(a,b,c)=> Math.min(a.x,b.x)-1e-6<=c.x && c.x<=Math.max(a.x,b.x)+1e-6 && Math.min(a.y,b.y)-1e-6<=c.y && c.y<=Math.max(a.y,b.y)+1e-6;
    const inter=(p1,p2,q1,q2)=>{
      const o1=orient(p1,p2,q1),o2=orient(p1,p2,q2),o3=orient(q1,q2,p1),o4=orient(q1,q2,p2);
      if((o1*o2<0)&&(o3*o4<0)) return true;
      if(Math.abs(o1)<1e-8 && onSeg(p1,p2,q1)) return true;
      if(Math.abs(o2)<1e-8 && onSeg(p1,p2,q2)) return true;
      if(Math.abs(o3)<1e-8 && onSeg(q1,q2,p1)) return true;
      if(Math.abs(o4)<1e-8 && onSeg(q1,q2,p2)) return true;
      return false;
    };
    for(const s of segs){
      if(inter(pFrom,pTo,s.a,s.b)){
        if(band==='2.4') loss += (s.att24 ?? s.att ?? 0);
        else              loss += (s.att5  ?? s.att ?? 0);
      }
    }
    return loss;
  }

  _rssiFromAPs(x,y){
    if(!this.aps.length || !this.scalePxPerMeter) return RSSI_MIN;
    const P={x,y}; let sum_mW=0;
    for(const a of this.aps){
      const d_px=Math.hypot(x-a.x,y-a.y);
      const d_m=Math.max(1e-3, d_px/this.scalePxPerMeter);
      const n=N_BY_BAND[a.band||'5'] ?? 2.3;
      const lossObs=this._pathObstacleLoss(P,a,a.band||'5');
      const rssi=a.p0 - 10*n*Math.log10(d_m) - lossObs;
      sum_mW += Math.pow(10, rssi/10);
    }
    return 10*Math.log10(Math.max(1e-15,sum_mW));
  }

  _buildHeat(){
    if(this.buildingHeat) return;
    this.buildingHeat=true;
    this.heatCanvas=document.createElement('canvas'); this.heatCanvas.width=this.worldW; this.heatCanvas.height=this.worldH;
    const hctx=this.heatCanvas.getContext('2d',{willReadFrequently:true});
    const img=hctx.createImageData(this.worldW,this.worldH), arr=img.data;
    this.heatField=new Float32Array(this.worldW*this.worldH);
    for(let y=0;y<this.worldH;y++){
      for(let x=0;x<this.worldW;x++){
        const rssi=this._rssiFromAPs(x,y); const [r,g,b]=this._colorFromRSSI(rssi);
        this.heatField[y*this.worldW+x]=rssi;
        const i=(y*this.worldW+x)*4; arr[i]=r; arr[i+1]=g; arr[i+2]=b; arr[i+3]=255;
      }
    }
    hctx.putImageData(img,0,0);
    this.buildingHeat=false;
  }

  renderHeatmap(){
    if(!this.aps.length){ alert('ยังไม่มี AP — วาง AP ก่อน'); return; }
    this.UI.legendMin.textContent=RSSI_MIN; this.UI.legendMax.textContent=RSSI_MAX; this._makeFixedLegend();
    this._buildHeat();
    const alpha=clamp(parseFloat(this.UI.alpha?.value||'0.6'),0,1);
    const blurPx=Math.max(0,parseInt(this.UI.blurPx?.value||'16',10));
    this._drawBase();
    if(this.heatCanvas){
      const ctx=this.ctx;
      ctx.save(); ctx.setTransform(this.view.scale,0,0,this.view.scale,this.view.tx,this.view.ty);
      ctx.globalAlpha=alpha; if(blurPx>0) ctx.filter=`blur(${blurPx}px)`;
      ctx.drawImage(this.heatCanvas,0,0,this.worldW,this.worldH);
      ctx.filter='none'; ctx.globalAlpha=1; ctx.restore();
    }
    this._drawPermanent();
    this._drawContours(CONTOUR_LEVELS,2);
    this.hasRendered=true;
  }

  /* ===== probe ===== */
  _showProbeAtScreen(sx,sy,wx,wy){
    this._drawAll();
    const ctx=this.ctx;
    ctx.save(); ctx.setTransform(1,0,0,1,0,0);
    ctx.beginPath(); ctx.arc(sx,sy,6,0,Math.PI*2); ctx.fillStyle='#fff'; ctx.globalAlpha=.9; ctx.fill();
    ctx.lineWidth=2; ctx.strokeStyle='#000'; ctx.globalAlpha=1; ctx.stroke(); ctx.restore();

    const rssi=this._rssiFromAPs(wx,wy), col=this._colorFromRSSI(rssi);
    this.UI.probeVal.textContent=`${rssi.toFixed(1)} dBm`; this.UI.probeMeta.textContent=`x=${wx|0}, y=${wy|0}`;
    this.UI.probe.style.left=`${sx+10}px`; this.UI.probe.style.top=`${sy-10}px`; this.UI.probe.style.display='block';
    this.UI.probeSw.style.background = rgbStr(col);
  }
  _hideProbe(){ this.UI.probe.style.display='none'; }

  /* ===== UI bindings ===== */
  _wireUI(){
    // zoom buttons
    this.UI.btnZoomIn.onclick =()=>this._zoomAt(this.canvas.width/2,this.canvas.height/2,1.25);
    this.UI.btnZoomOut.onclick=()=>this._zoomAt(this.canvas.width/2,this.canvas.height/2,0.8);
    this.UI.btnZoomReset.onclick=()=>this._resetView();

    // wheel zoom
    this.canvas.addEventListener('wheel', e=>{
      e.preventDefault();
      const r=this.canvas.getBoundingClientRect(), cx=e.clientX-r.left, cy=e.clientY-r.top;
      this._zoomAt(cx,cy, e.deltaY<0 ? 1.12 : 0.9);
    },{passive:false});

    // pan with Space
    document.addEventListener('keydown', e=>{ if(e.code==='Space') this.spacePan=true; if(e.key==='Escape'){ this.mode='idle'; this.UI.modeBadge.textContent='โหมด: Idle'; this._hideProbe(); }});
    document.addEventListener('keyup',   e=>{ if(e.code==='Space') this.spacePan=false; });

    this.canvas.addEventListener('mousedown', e=>{
      const {screen,world}=this._getCanvasPos(e);
      if(this.spacePan||e.button===1){ this.panAnchor={ x:screen.x, y:screen.y, tx:this.view.tx, ty:this.view.ty }; return; }
      if(this.mode==='scale' || this.mode==='mat') this._startDrag(world.x,world.y);
    });
    this.canvas.addEventListener('mousemove', e=>{
      const {screen,world}=this._getCanvasPos(e);
      if(this.panAnchor){ const dx=screen.x-this.panAnchor.x, dy=screen.y-this.panAnchor.y; this._setView(this.view.scale, this.panAnchor.tx+dx, this.panAnchor.ty+dy); return; }
      if(this.mode==='scale' || this.mode==='mat') this._updateDrag(world.x,world.y);
    });
    this.canvas.addEventListener('mouseup', e=>{
      if(this.panAnchor){ this.panAnchor=null; return; }
      const {world}=this._getCanvasPos(e);
      if(this.mode==='scale' || this.mode==='mat') this._endDrag(world.x,world.y);
    });
    this.canvas.addEventListener('mouseleave', ()=>{ this.panAnchor=null; this.dragging=false; this.dragStart=null; this.octx.clearRect(0,0,this.overlay.width,this.overlay.height); });

    // toolbar buttons
    this.UI.btnScale.onclick=()=>{ this.mode='scale'; this.UI.modeBadge.textContent='โหมด: ตั้งสเกล'; this._hideProbe(); };
    this.UI.btnIdle.onclick =()=>{ this.mode='idle';  this.UI.modeBadge.textContent='โหมด: Idle'; this._hideProbe(); };
    this.UI.btnAP.onclick   =()=>{ this.mode='ap';    this.UI.modeBadge.textContent='โหมด: วาง AP (คลิก)'; this._hideProbe(); };
    this.UI.btnMat.onclick  =()=>{ this.mode='mat';   this.UI.modeBadge.textContent='โหมด: วัสดุ (ลากเส้น)'; this._hideProbe(); };

    this.UI.btnAPUndo.onclick =()=>{ this.aps.pop(); this._drawAll(); this._refreshAPList(); };
    this.UI.btnAPClear.onclick=()=>{ if(confirm('ล้าง AP ทั้งหมด?')){ this.aps=[]; this._drawAll(); this._refreshAPList(); } };
    this.UI.btnMatUndo.onclick =()=>{ this.segments.pop(); this._drawAll(); this._refreshMatList(); };
    this.UI.btnMatClear.onclick=()=>{ if(confirm('ล้างวัสดุทั้งหมด?')){ this.segments=[]; this._drawAll(); this._refreshMatList(); } };

    this.UI.btnRender.onclick =()=>{ this.renderHeatmap(); this._hideProbe(); };
    this.UI.btnExport.onclick =()=>{ const a=document.createElement('a'); a.download='heatmap.png'; a.href=this.canvas.toDataURL('image/png'); a.click(); };

    this.UI.btnSave.onclick=()=>{
      const payload={ aps:this.aps, segments:this.segments, alpha:+(this.UI.alpha?.value||0.6), blurPx:+(this.UI.blurPx?.value||16),
        scale:this.scalePxPerMeter, worldW:this.worldW, worldH:this.worldH };
      const blob=new Blob([JSON.stringify(payload,null,2)],{type:"application/json"});
      const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=`heatmap_project_${this.p.toLowerCase()}.json`; a.click();
      URL.revokeObjectURL(a.href);
    };
    this.UI.loadJson?.addEventListener('change', e=>{
      const f=e.target.files[0]; if(!f) return;
      const reader=new FileReader();
      reader.onload=()=>{
        try{
          const obj=JSON.parse(reader.result);
          this.aps=obj.aps||[]; this.segments=(obj.segments||[]).map(s=>{
            if(s.att24==null && s.att5==null){
              const base24 = s.att ?? 8;
              const def = MATERIALS[s.type]?.att || {'2.4':base24,'5':base24};
              const ratio = (def['5']||base24)/(def['2.4']||base24);
              return {...s, att24:+base24.toFixed(1), att5:+(base24*ratio).toFixed(1)};
            }
            return s;
          });
          if(this.UI.alpha)  this.UI.alpha.value=obj.alpha??0.6;
          if(this.UI.blurPx) this.UI.blurPx.value=obj.blurPx??16;
          this.scalePxPerMeter=obj.scale||null;
          this.worldW=obj.worldW||this.worldW; this.worldH=obj.worldH||this.worldH;
          this.UI.scaleLabel.textContent=this.scalePxPerMeter?`${this.scalePxPerMeter.toFixed(1)} px/เมตร`:'ยังไม่ตั้ง';
          this._resetView(); this._drawAll(); this._refreshAPList(); this._refreshMatList();
        }catch(err){ alert('Invalid project JSON'); }
      };
      reader.readAsText(f);
    });

    // image loader
    this.UI.fileInput?.addEventListener('change', e=>{
      const f=e.target.files[0]; if(!f) return;
      const img=new Image();
      img.onload=()=>{ this.floorImg=img; this.worldW=img.naturalWidth; this.worldH=img.naturalHeight; this._resetView(); this._drawAll(); };
      img.src=URL.createObjectURL(f);
    });
    this.UI.btnClear.onclick=()=>{ this.floorImg=null; this._resetView(); this._drawAll(); };

    // keyboard
    document.addEventListener('keydown', e=>{
      if(e.key==='s'||e.key==='S'){ this.mode='scale'; this.UI.modeBadge.textContent='โหมด: ตั้งสเกล'; this._hideProbe(); }
      if(e.key==='a'||e.key==='A'){ this.mode='ap';    this.UI.modeBadge.textContent='โหมด: วาง AP (คลิก)'; this._hideProbe(); }
      if(e.key==='w'||e.key==='W'){ this.mode='mat';   this.UI.modeBadge.textContent='โหมด: วัสดุ (ลากเส้น)'; this._hideProbe(); }
      if(e.key==='h'||e.key==='H'){ this.renderHeatmap(); this._hideProbe(); }
      if(e.key==='Escape'){ this.mode='idle'; this.UI.modeBadge.textContent='โหมด: Idle'; this._hideProbe(); }
    });

    // canvas click: place AP / probe
    this.canvas.addEventListener('click', e=>{
      if(this.panAnchor) return;
      const {world,screen}=this._getCanvasPos(e);
      if(this.mode==='ap'){
        if(!this.scalePxPerMeter){ this.scalePxPerMeter=100; this.UI.scaleLabel.textContent='100 px/เมตร (อัตโนมัติ)'; }
        const label=this.UI.apLabel.value.trim()||`AP-${this.aps.length+1}`;
        const p0=parseFloat(this.UI.apP0.value||'-40');
        const band=this.UI.apBand.value||'5';
        const preset=window.__currentApPreset?{presetName:window.__currentApPreset.name}:undefined;
        this.aps.push({x:world.x,y:world.y,label,p0,band,preset});
        this._drawAll(); this._refreshAPList();
      }else if(this.mode==='idle'){
        if(!this.hasRendered) return;
        this._showProbeAtScreen(screen.x, screen.y, world.x, world.y);
      }
    });
  }

  _zoomAt(cx,cy,f){
    const old=this.view.scale, ns=clamp(old*f,this.view.min,this.view.max); if(ns===old) return;
    const wx=(cx-this.view.tx)/old, wy=(cy-this.view.ty)/old;
    const ntx=cx-wx*ns, nty=cy-wy*ns;
    this._setView(ns,ntx,nty);
  }

  _startDrag(x,y){ this.dragging=true; this.dragStart={x,y}; this.octx.clearRect(0,0,this.overlay.width,this.overlay.height); }
  _updateDrag(x,y){
    if(!this.dragging||!this.dragStart) return;
    const label=(this.mode==='scale')? `${Math.hypot(x-this.dragStart.x,y-this.dragStart.y).toFixed(1)} px`
      : `${MATERIALS[this.UI.matType.value]?.name||'วัสดุ'} · 2.4:${(this.UI.matAtt.value||'0')} dB`;
    this._drawArrowWorld(this.dragStart,{x,y},{color:(this.mode==='scale')?'#6ae3ff':'#ffd36a', label});
  }
  _endDrag(x,y){
    if(!this.dragging||!this.dragStart) return;
    this.octx.clearRect(0,0,this.overlay.width,this.overlay.height);
    const a={...this.dragStart}, b={x,y};
    if(this.mode==='scale'){
      const Lpx=Math.hypot(a.x-b.x,a.y-b.y), real=prompt(`ความยาวจริง (เมตร) ของไม้บรรทัด ${Lpx.toFixed(1)} px = ?`, '5');
      if(real && +real>0){ this.scalePxPerMeter=Lpx/(+real); this.UI.scaleLabel.textContent=`${this.scalePxPerMeter.toFixed(1)} px/เมตร`; }
      this.mode='idle'; this.UI.modeBadge.textContent='โหมด: Idle'; this._drawAll();
    }else if(this.mode==='mat'){
      const type=this.UI.matType.value;
      const base24=parseFloat(this.UI.matAtt.value)|| (MATERIALS[type]?.att?.['2.4'] ?? 8);
      const def = MATERIALS[type]?.att || {'2.4':base24,'5':base24};
      const ratio = (def['5']||base24)/(def['2.4']||base24);
      const att24=+base24.toFixed(1), att5=+(base24*ratio).toFixed(1);
      this.segments.push({a,b,type,att24,att5});
      this.mode='idle'; this.UI.modeBadge.textContent='โหมด: Idle'; this._drawAll(); this._refreshMatList();
    }
    this.dragging=false; this.dragStart=null;
  }
  _drawArrowWorld(a,b,opts={}){
    const {color='#6ae3ff',width=3.5,head=12,dash=[10,6],label=''}=opts;
    const octx=this.octx; octx.save(); octx.clearRect(0,0,this.overlay.width,this.overlay.height); octx.setTransform(1,0,0,1,0,0);
    const A=this._worldToScreen(a), B=this._worldToScreen(b);
    octx.lineWidth=width; octx.setLineDash(dash); octx.strokeStyle=color;
    octx.beginPath(); octx.moveTo(A.x,A.y); octx.lineTo(B.x,B.y); octx.stroke();
    octx.setLineDash([]);
    const ang=Math.atan2(B.y-A.y,B.x-A.x);
    octx.beginPath(); octx.moveTo(B.x,B.y);
    octx.lineTo(B.x-head*Math.cos(ang - Math.PI/7), B.y-head*Math.sin(ang - Math.PI/7));
    octx.lineTo(B.x-head*Math.cos(ang + Math.PI/7), B.y-head*Math.sin(ang + Math.PI/7));
    octx.closePath(); octx.fillStyle=color; octx.fill();
    octx.fillStyle='#fff'; octx.strokeStyle='#000'; octx.lineWidth=2;
    [A,B].forEach(p=>{ octx.beginPath(); octx.arc(p.x,p.y,4,0,Math.PI*2); octx.fill(); octx.stroke(); });
    if(label){ octx.font='12px ui-monospace,monospace'; octx.fillStyle='#cfe6ff'; octx.fillText(label, B.x+10, B.y-8); }
    octx.restore();
  }

  _refreshAPList(){
    const list=this.UI.apList; list.innerHTML='';
    this.aps.forEach((a,i)=>{
      const row=document.createElement('div'); row.className='apRow small';
      row.innerHTML=`<div><strong>${this._escape(a.label||'AP')}</strong> · P0:${a.p0} dBm · ${a.band||'5'}GHz
        <div class="muted">(${a.x|0},${a.y|0}) ${a.preset?`· preset: ${this._escape(a.preset.presetName)}`:''}</div></div>
        <div class="row"><button data-i="${i}" class="danger" style="padding:4px 8px">ลบ</button></div>`;
      row.querySelector('button').onclick=e=>{ this.aps.splice(+e.target.getAttribute('data-i'),1); this._drawAll(); this._refreshAPList(); };
      list.appendChild(row);
    });
  }
  _refreshMatList(){
    const list=this.UI.matList; list.innerHTML='';
    this.segments.forEach((s,i)=>{
      const m=MATERIALS[s.type]||{name:s.type,color:'#fff'};
      const row=document.createElement('div'); row.className='matRow small';
      row.innerHTML=`<div style="display:flex;align-items:center;gap:8px">
          <span class="dot" style="background:${m.color}"></span>
          <div><div><strong>${m.name}</strong> · 2.4:${s.att24} dB · 5:${s.att5} dB</div>
          <div class="muted">A(${s.a.x|0},${s.a.y|0}) → B(${s.b.x|0},${s.b.y|0})</div></div>
        </div>
        <div class="row"><button data-i="${i}" class="danger" style="padding:4px 8px">ลบ</button></div>`;
      row.querySelector('button').onclick=e=>{ this.segments.splice(+e.target.getAttribute('data-i'),1); this._drawAll(); this._refreshMatList(); };
      list.appendChild(row);
    });
  }
  _escape(s){ return (s+'').replace(/[&<>"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

  _initMatDrop(){
    const sel=this.UI.matType;
    Object.keys(MATERIALS).forEach(k=>{ const o=document.createElement('option'); o.value=k; o.textContent=MATERIALS[k].name; sel.appendChild(o); });
    sel.value='brick'; this.UI.matAtt.value=MATERIALS['brick'].att['2.4'];
    sel.addEventListener('change',()=>this.UI.matAtt.value=MATERIALS[sel.value].att['2.4']);
  }

  async _loadApPresets(){
    const sel=this.UI.apPreset; if(!sel) return;
    sel.innerHTML='<option value="">(กำลังโหลดพรีเซ็ต...)</option>';
    try{
      const res=await fetch('./ap_presets.json',{cache:'no-store'});
      if(!res.ok) throw new Error(res.statusText);
      this.AP_PRESETS=await res.json();
      sel.innerHTML='<option value="">-- เลือกรุ่น --</option>';
      Object.keys(this.AP_PRESETS).forEach(name=>{ const o=document.createElement('option'); o.value=name; o.textContent=name; sel.appendChild(o); });
    }catch(e){ sel.innerHTML='<option value="">(โหลดพรีเซ็ตไม่ได้)</option>'; console.error(e); }
    this.UI.btnUsePreset?.addEventListener('click', ()=>{
      const name=(sel.value||'').trim(); if(!name||!this.AP_PRESETS[name]) return;
      const ap=this.AP_PRESETS[name];
      this.UI.apLabel.value=name;
      const bandSel=this.UI.apBand; const band=ap.bands?.includes('5')?'5':(ap.bands?.[0]||'2.4'); bandSel.value=band;
      if(ap.p0 && ap.p0[band]!=null) this.UI.apP0.value=ap.p0[band];
      window.__currentApPreset={name};
    });
  }
}

/* ===== สร้างอินสแตนซ์สองตัว แยกกัน แต่หน้าตาเหมือนกัน 100% ===== */
const AppPlanning = new WiFiApp('Planning');
const AppSurvey   = new WiFiApp('Survey');
